# Crypto on the cache
The `encryption`, `decryption`, `signature` and `verification` features ensures cryptographic confidentially and integrity on HTTP [responses](https://developer.mozilla.org/en-US/docs/Web/API/Response) stored by service workers in the web applications [cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) in the browser. The key used to performed the cryptographic operations is derived from [random bytes](#random-bytes)  (i) securely generated by a trusted third party secure random bytes generator (ii); downloaded and cached in by the browser and (iii) solely accessible to the right service worker that they were generated for. 

As the name suggests, the `encryption` feature [encrypts](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt) HTTP responses before they are stored in the cache. The dual counterpart of the `encryption` feature is the `decryption` feature, which [decrypts](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt) encrypted HTTP responses right after they are retrieved from the cache. Likewise, the `signature` feature [signs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign) HTTP responses before they are stored in the cache. More precisely, this operation computes the [hash-based message authentication codes (HMAC)](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#hmac) of HTTP responses. Dually, the `verification` feature checks the signature of signed (HMACed) HTTP responses right after they are read from the cache. 

Methods that store HTTP responses in the cache include:
- [Cache.put](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put) 
- [Cache.addAll](https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll) 
- [Cache.add](https://developer.mozilla.org/en-US/docs/Web/API/Cache/add)

Dually, methods that read HTTP responses from the cache include:
- [Cache.match](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
- [CacheStorage.match](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match)



### Encryption
Given a request and a response objects, encryptions:
- the plaintext to be encrypted is an JSON-stringified object containing the following properties of the HTTP response and request objects, further converted to an ArrayBuffer:
	- the [response body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) serialized as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer) and converted to a string
	- the [response headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers) which are serialized as an object associating header names as properties to their values. 
	- the [response status](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) code, i.e. 200
	- the [response status text](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText)
	- the [request URL](https://developer.mozilla.org/en-US/docs/Web/API/Request/url)
- the key used to performed the encryption is derived from secure [random bytes](#random-bytes)
- encryption is performed using the [AES-GCM](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#aes-gcm) algorithm with require an [initialization vector (IV)](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters), generated in the browser using the [Crypto.getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) method. A new IV is generated for each HTTP response that is to be be encrypted.


The cipher text obtained after [encryption](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt), and the IV generated for the encryption are combined in a [new response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response) object where:
- the response body is the cipher text
- the response headers contains a single entry consisting of the [CORS-safelisted](https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header) [last-modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) response header whose value is the IV, serialized as  a string of bytes

Finally, the new response is associated to the request, and [stored in the cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put) 


### Decryption
As one may guess, the `decryption` feature is the exact opposite of the `encryption` feature and follows opposite steps in order to recover the plain responses that have been previously encrypted and stored in the cache. Given a request object, and the associated response read from the cache, decryption proceeds as follow:
- the cipher text is the response body, serialized as an ArrayBuffer
- the IV is extracted from the `last-modified` header from the response
- [decryption](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt) is then performed using the cipher text, the IV, the `AES-GCM` algorithm and the cryptograhic key derived from the [random bytes](#random-bytes)
- the decrypted response is deserialized to obtain a JSON-object with the original response body, headers, status, status text, and request URL.
- the decrypted request URL is matched against the request URL provided at the beginning of the decryption. In case of a match, the original response is reconstructed using the original response body, headers, status and status text. 


### Signature
The `signature` feature works very similarly to `encryption`.
- it works with the `HMAC` and `SHA-512` algoritms
- the key used to compute the signature (HMAC) is derived from secure [random bytes](#random-bytes)
- the message to sign is an JSON-stringified object containing the following properties of the HTTP response and request objects, further converted to an ArrayBuffer:
	- the [response body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) serialized as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer) and converted to a string
	- the [response headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers) which are serialized as an object associating header names as properties to their values. In particular, we disregard the `last-modified` header if there is one.
	- the [response status](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) code, i.e. 200
	- the [response status text](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText)
	- the [request URL](https://developer.mozilla.org/en-US/docs/Web/API/Request/url)

The signature of the message is added to the original response, as the value of the CORS-safelist [last-modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) response header. The modified response (containing the signature) is then associated to the request, and [stored in the cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put). 

### Verification
As one may guess, the `verification` feature is the complement of the `signature`. It follows similar steps as `signature` to first recompute a signature of a response, then compares it to the signature stored in the `last-modified` response header. Given a request object, and the associated response read from the cache, verification proceeds as follow:
- the `HMAC` and `SHA-512` algoritms are used
- the key used to compute the signature (HMAC) is derived from secure [random bytes](#random-bytes)
- the message to recompute signature for is an JSON-stringified object containing the following properties of the HTTP response and request objects, further converted to an ArrayBuffer:
	- the [response body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) serialized as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer) and converted to a string
	- the [response headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers) which are serialized as an object associating header names as properties to their values. In particular, we disregard the `last-modified` header
	- the [response status](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) code, i.e. 200
	- the [response status text](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText)
	- the [request URL](https://developer.mozilla.org/en-US/docs/Web/API/Request/url)
- the stored signature is extracted from the `last-modified` header of the response
- the stored signature is matched against the one that has just been recomputed. If there is a match, the cached response is used, otherwise, a fresh one is downloaded over the network. 



### Security analysis
Intuitively, if the encrypted response has been tampered with, at least one of the decryption steps will fail, and the service worker will fetch a fresh response from the remote server, encryt and store a copy in the cache, and return a plain copy to the client. There are many ways an attacker may tamper with the cached content. Since the attacker only sees the encrytped response and the IV, it can:
1. modify the IV or cipher text: in this case, the decryption will simply fail, as the IV and cipher text need to match in order for the decryption to be successful. 
2. replace the cipher text and the IV: here the attacker is replacing the IV and cipher text with  valid cipher text and IV read from other encrypted responses stored in the cache. This tampering will be detected because they will be mismatch between the request URL stored in the encrypted response and the request URL the response is associated to. 
3. replace the encrypted response with a plain response or tampering with an unencrypted response: the decryption of a plain response will fail and thus detected as a tampering attempt.

As for encryption and decryption, the attacker may also modify or replace signed responses:
1. modify the signature or the original response: in this case, the verification will fail, since the signature must match the original response
2. replace the signed response with a valid signed response from another request: because the request URL is included in the message for the recomputed signature, the verification will fail.
3. replace the signed response with a plain one or tampering with an unsigned response: the verification of a plain response will fail since the service worker will not find a matching signature in its headers. 




## Crypto and the same-origin policy
It is worth noting that all the crypto features operate on HTTP responses whose bodies are readable, i.e. [responses of types](https://developer.mozilla.org/en-US/docs/Web/API/Response/type) `basic`, `cors` and `default`. In particular, responses of type `default` are responses that are programmatically created by service workers. 

These operations are fully compliant with the [same-origin policy (SOP)](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy), [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) and the [Fetch Standard](https://fetch.spec.whatwg.org/). Responses of other types, i.e. `opaque`, are not applied cryptographic features, i.e. `encryption` or `signature`. Nonetheless, if an attacker modifies those responses, their types will change to `default`. When read from the cache, the service worker will apply the `decryption` or `verification` feature to them. At this point, the crypographic operations will fail, leading to the download of a fresh response form the remote web server.

Furthermore, leveraging the [CORS-safelisted](https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header) [last-modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) header for storing the IV used during encryption or the signature computed for a response also strictly follows the SOP and CORS, since safelisted response headers are allowed to be manipulated on same-origin as well as CORS responses. 

## Random bytes
The crypto features require a `randomBytes` option that holds random bytes crpytographic keys are derived from in order to perform the different operations. First of all, the entity (i.e. web server, CDN, etc.) that generates the random bytes for a web site MUST be from a different origin than the website. In other words, one should use a trusted third party server or CDN to generate the random bytes. In this settings, there are still many security requirements for the generation and delivery of the random bytes:
1. `secure`: the random bytes must be generated using `cryptograhpically secure random` algorithms. Many implementations exist for different languages, i.e. the crypto module [for Node.js](https://nodejs.org/api/crypto.html#cryptogetrandomvaluestypedarray) and [JavaScript](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues), [the secrets module for Python](https://docs.python.org/3/library/secrets.html#secrets.token_bytes), etc. The bytes should be 16 or 32 bytes long. In our implementation, we generate 32 bytes.
2. `persistent`: the random bytes must be persisted, for the dual operation, i.e. `decryption` to be properly performed with the same bytes. This is achieved by delivering the HTTP response that holds the random bytes, with a [Cache-control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) response header. The following directives are leveraged:
	- `max-age` directive set to the lifetime of the random bytes in the cache. Note that in browsers, the cache where the random bytes are persisted is not the service workers cache, but rather the browser [HTTP cache](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching). In fact, attackers can programmatically read the service worker cache, but not the [browser HTTP cache](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)
	- `private` directive to mandate that the random bytes be stored only in browser's cache, and not on intermediate proxies on the response route (i.e. CDN)
	- no `must-revalidate`: to allow the offline use of expired random bytes, until the user is back online.
3. `secret`: the random bytes must only be accessible to the right service worker they are destined to. Not even (potentially malicious) scripts running in other same-origin contexts (i.e. web pages, shared and dedicated workers) should have access to the random bytes. This property is achieved by leveraging defensive JavaScript programming, [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) and unforgeable browser properties such as the [Referer header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) and [location](https://developer.mozilla.org/en-US/docs/Web/API/Location) object. In other words, the random bytes are wrapped and delivered in a JavaScript response code. To do so, the request to the third party random bytes generator must include an `origin` parameter containing the service worker's origin and an `href` paramater containing the service worker whole URL. The third party then checks that the value of the `href` parameter matches (i.e. starts with the value of the `origin` parameter). If there is a mismatch, random bytes are not generated. Other, the random bytes are generated. A IIFE is constructed to hold...


The obove 3 requirements effectively protects the random bytes, making them only accessible to the service worker they were generated for. Additionally, service workers that have a [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) header with certain directives can enjoy more security for the random bytes. 


We have 2 implementations 

## Random bytes generators


## Examples


## Browser compatibility

## Threat models
The attacker is a malicious script running in a web page, shared or dedicated worker. The attacker  manipulates HTTP responses that are in the cache, with the goal to trick the service worker into serving those tampered responses when they are requested. The attacker

### Access CSP-sandboxed iframes 

### Enable clickjacing x-frame-options: DENY

### Relax security policies 
- permissions-policy to request a permission on behalf of the web site
- introduce exploitable bugs in a web app

### Reorder the execution of scripts



