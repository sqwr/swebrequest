# Crypto on the cache
The `encryption`, `decryption`, `signature` and `verification` features ensures cryptographic confidentially and integrity on HTTP [responses](https://developer.mozilla.org/en-US/docs/Web/API/Response) stored by service workers in the web applications [cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) in the browser. The key used to performed the cryptographic operations is derived from [random bytes](#random-bytes)  (i) securely generated by a trusted third party secure random bytes generator (ii); downloaded and cached in by the browser and (iii) solely accessible to the right service worker that they were generated for. 

As the name suggests, the `encryption` feature [encrypts](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt) HTTP responses before they are stored in the cache. The dual counterpart of the `encryption` feature is the `decryption` feature, which [decrypts](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt) encrypted HTTP responses right after they are retrieved from the cache. Likewise, the `signature` feature [signs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign) HTTP responses before they are stored in the cache. More precisely, this operation computes the [hash-based message authentication codes (HMAC)](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#hmac) of HTTP responses. Dually, the `verification` feature checks the signature of signed (HMACed) HTTP responses right after they are read from the cache. 

Methods that store HTTP responses in the cache include:
- [Cache.put](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put) 
- [Cache.addAll](https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll) 
- [Cache.add](https://developer.mozilla.org/en-US/docs/Web/API/Cache/add)

Dually, methods that read HTTP responses from the cache include:
- [Cache.match](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
- [CacheStorage.match](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/match)



### Encrypting HTTP responses
Given a request and a response objects, encryptions:
- are performed with the [AES-GCM](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#aes-gcm) algorithm. 
- the key used to performed the encryption is derived from secure [random bytes](#random-bytes) cached in the browser HTTP cache, and only accessible to the service worker. 
- require an [initialization vector (IV)](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters) which is generated in the browser using the [Crypto.getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) method. A new IV is generated for each HTTP response that is to be be encrypted.
- the plaintext to be encrypted is an JSON-stringify object containing the following properties of the HTTP response and request objects, further converted to an ArrayBuffer:
	- the [response body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) serialized as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer) and converted to a string
	- the [response headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers) which are serialized as an object associating header names as properties to their values. 
	- the [response status](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) code, i.e. 200
	- the [response status text](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText)
	- the [request URL](https://developer.mozilla.org/en-US/docs/Web/API/Request/url)

The cipher text obtained after [encryption](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt), and the IV generated for the encryption are used combined in a [new response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response) object where:
- the response body is the cipher text
- the response headers object contains the [CORS-safelisted](https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header) [last-modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) response header whose value is the IV, serialized as string of bytes
- the new response is associated to the request, and [stored in the cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache/put) 

### Decrypting HTTP responses
As one may guess, the `decryption` feature is the exact opposite of the `encryption` feature and follows opposite steps in order to recover the plain responses that have been previously encrypted and stored in the cache. Given a request object, and the associated response read from the cache, decryption proceeds as follow:
- the cipher text is the response body, serialized as an ArrayBuffer
- the IV is extracted from the `last-modified` header from the response
- [decryption](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt) is then performed using the cipher text, the IV, the `AES-GCM` algorithm and the cryptograhic key derived from the [random bytes](#random-bytes)
- the decrypted response is deserialized to obtain a JSON-object with the origin response body, headers, status, status text, and request URL.
- the decrypted request URL is matched against the request URL provided at the beginning of the decryption. 
- the original response is reconstructed using the original response body, headers, status and status text. 

### Security analysis
Intuitively, if the encrypted response has been tampered with, at least one of the decryption steps will fail, and the service worker will fetch a fresh response from the remote server, encryt and store a copy in the cache, and return a plain copy to the client. There are many ways an attacker may tamper with the cached content. Since the attacker only sees the encrytped response and the IV, it can:
1. modify the IV or cipher text: in this case, the decryption will simply fail, as the IV and cipher text need to match in order for the decryption to be successful. 
2. replace the cipher text and the IV: here the attacker is replacing the IV and cipher text with  valid cipher text and IV read from other encrypted responses stored in the cache. This tampering will be detected because they will be mismatch between the request URL stored in the encrypted response and the request URL the response is associated to. 
3. replace the encrypted response with a plain response or tampering with an unencrypted response: the decryption of a plain response will fail and thus detected as a tampering attempt.

## Crypto and the same-origin policy
It is worth noting that all the crypto features operate on HTTP responses whose body are readable, i.e. [responses of types](https://developer.mozilla.org/en-US/docs/Web/API/Response/type) `basic`, `cors` and `default`. In particular, responses of type `default` are responses that are programmatically created. This is fully compliant with the [same-origin policy (SOP)](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy), [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) and the [Fetch Standard](https://fetch.spec.whatwg.org/). Responses of other types, i.e. `opaque`, are not applied cryptographic features, i.e. `encryption` or `signature`. Nonetheless, if an attacker modifies those responses, their types will change to `default`. When read from the cache, the service worker will apply the `decryption` or `verification` feature to them. At this point, the crypographic operation will fail, leading to the download of a fresh response form the remote web server.

Furthermore, leveraging the [CORS-safelisted](https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header) [last-modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) header for storing the IV used during encryption also strictly follows the SOP and CORS, since safelisted response headers are allowed to be manipulated on same-origin as well as CORS responses. 


### Encryption scheme for HTTP responses
The [encrypt](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt) method requires:
- a key which is 
requires a 16-bytes [initialization vector (iv)](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters) which are generated in the browser using the [Crypto.getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) method. A new IV is generated for each HTTP response that is to be encrypted. As the IV does not need to be secret, it is stored in clear along the ciphered HTTP response in the cache

### Decryption


## Signature and verification


## Crypto schemes

## Plain text or message
The plaintext to be encrypted or the message to be signed (HMACed) is made of the following properties of the HTTP response object:
- the [response body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) serialized as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/API/Response/arrayBuffer)
- the [response headers](https://developer.mozilla.org/en-US/docs/Web/API/Response/headers) which are serialized as an object associating header names as properties to their values. 
- the [response status](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) code, i.e. 200
- the [response status text](https://developer.mozilla.org/en-US/docs/Web/API/Response/statusText)
- the underlying [request URL](https://developer.mozilla.org/en-US/docs/Web/API/Request/url)



### Decryption and verification scheme



### Signature and verification
- the `signature` feature [signs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign) HTTP responses before 


Encryption is performed with the [AES-GCM](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#aes-gcm) algorithm. 

## Random bytes
The `encryption` feature requires a `randomBytes` option that holds  random bytes to be used to perform the encryption on responses. First of all, the entity (i.e. web server, CDN, etc.) that generates the random bytes for a web site MUST be from a different origin than the website. In other words, once should use a trusted third party server or CDN to generate the website. In this settings, there are still many many security requirements for the generation and delivery of the random bytes:
1. `secure`: the random bytes must be generated using `cryptograhpically secure random` algorithms. Many implementations exist for different languages, i.e. the crypto module [for Node.js](https://nodejs.org/api/crypto.html#cryptogetrandomvaluestypedarray) and [JavaScript](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues), [the secrets module for Python](https://docs.python.org/3/library/secrets.html#secrets.token_bytes), etc. 
2. `persistent`: the random bytes must be persisted, for the dual operation, i.e. `decryption` to be properly performed with the same bytes. This is achieved by delivering the HTTP response that holds the random bytes, with a [Cache-control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) response header. The following directives are leveraged:
	- `max-age` directive set to the lifetime of the random bytes in the cache. Note that in browsers, the cache where the random bytes are persisted is not the service workers cache, but rather the browser [HTTP cache](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching).
	- `private` directive to mandate that the random bytes be stored only in browser's cache, and not on intermediate proxies on the response route (i.e. CDN)
	- no `must-revalidate`: to allow the offline use of expired random bytes 
3. `secret`: the random bytes must only be accessible to the right service worker they are destined to. Not even (potentially malicious) scripts running in other same-origin contexts (i.e. web pages, shared and dedicated workers) should have access to the random bytes. This property is achieved by leveraging defensive JavaScript programming, [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) and unforgeable browser properties such as the [Referer header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) and [location](https://developer.mozilla.org/en-US/docs/Web/API/Location) object.

The obove 3 requirements effectively protects the random bytes, making them only accessible to the service worker they were generated for. Additionally, service workers that have a [Referrer-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy) header with certain directives can enjoy more security for the random bytes. 


We have 2 implementations 

## Random bytes generators


## Examples


## Browser compatibility

## Threat models
The attacker is a malicious script running in a web page, shared or dedicated worker. The attacker  manipulates HTTP responses that are in the cache, with the goal to trick the service worker into serving those tampered responses when they are requested. The attacker

### Access CSP-sandboxed iframes 

### Enable clickjacing x-frame-options: DENY

### Relax security policies 
- permissions-policy to request a permission on behalf of the web site
- introduce exploitable bugs in a web app

### Reorder the execution of scripts